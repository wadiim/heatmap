#!/bin/bash

# DEFAULTS

# Color lookup table (values are in sixel format):
declare -ga colors=(
        [0]="18;20;23"
        [1]="6;28;16"
        [2]="0;43;20"
        [3]="15;65;26"
        [4]="22;83;33"
)
declare -gi cell_size=16  # Cell size in pixels.
declare -gi margin_size=4 # Margin size in pixels.
declare -gi max_cols=32   # Max number of columns.

# GLOBALS

declare -ga input               # Input values.
declare -gi min max             # Min/max input values.
declare -ga cells               # Color codes of individual cells.
declare -ga pixmap              # Color codes of individual pixels.
                                # Values of -1 represents background color.
declare -gi width height        # Width end height of the output heatmap in
                                # pixels.
declare -g  heatmap             # Sixel sequence defining the heatmap.
declare -gA binary_to_sixel_map # Mapping from binary numbers (stored as
                                # strings) to sixel characters. Needed for
				# performance reasons.

# Divide $1 by $2 and round the result to the nearest integer.
ndiv() {
	echo "$((($1 + ($2 / 2)) / $2))"
}

# Divide $1 by $2 and round the result up.
udiv() {
	echo "$((($1 + ($2 - 1)) / $2))"
}

# Find min and max input values.
find_min_max() {
        for val in "${input[@]}"; do
                # Remove non-integer values.
                if [[ ! $val =~ ^-?[0-9]+$ ]]; then
                        input=("${input[@]/$val/}")
                        continue
                fi

                if [[ ! -v min ]] || ((val < min)); then
                        min=$val
                fi
                if [[ ! -v max ]] || ((val > max)); then
                        max=$val
                fi
        done
}

# Map input values to color codes and fill the $cells array.
map_input_to_cells() {
        for val in "${input[@]}"; do
                if [[ $val == "" ]]; then
                        continue
                fi
                cells+=("$(ndiv $(((val - min) * (${#colors[@]} - 1))) $((max - min)))")
        done
}

# Convert cells to pixmap.
generate_pixmap() {
        local num_of_cols
	local num_of_rows

        if ((${#cells[@]} < max_cols)); then
                num_of_cols="${#cells[@]}"
        else
                num_of_cols="$max_cols"
        fi
        num_of_rows=$(udiv ${#cells[@]} $num_of_cols)

        width="$((cell_size * num_of_cols + margin_size * (num_of_cols - 1)))"
        height="$((cell_size * num_of_rows + margin_size * (num_of_rows - 1)))"

        for row in $(seq 0 $((num_of_rows - 1))); do
                for col in $(seq 0 $((num_of_cols - 1))); do
                        cell_idx=$((row * num_of_cols + col))
                        for y in $(seq 0 $((cell_size - 1))); do
                                for x in $(seq 0 $(((cell_size - 1) + margin_size))); do
					pixmap_idx=$((row * (cell_size + margin_size) * width + col * (cell_size + margin_size) + x + y * width))
                                        if ((x > (cell_size - 1))); then
                                                # Add vertical margin
                                                if ((col < (num_of_cols - 1))); then
                                                        pixmap[$pixmap_idx]=$((-1))
                                                else
                                                        continue
                                                fi
                                        else
                                                if ((cell_idx >= ${#cells[@]})); then
                                                        pixmap[$pixmap_idx]=$((-1))
                                                else
                                                        pixmap[$pixmap_idx]="$((${cells[$cell_idx]}))"
                                                fi
                                        fi
                                done
                        done
                done
                # Add horizontal margin
                if ((row < (num_of_rows - 1))); then
                        for i in $(seq 0 $((width * margin_size - 1))); do
                                pixmap+=("-1")
                        done
                fi
        done

        # Add bottom padding if necessary to make the pixmap height a multiple
        # of 6.
        while ((height % 6 != 0)); do
                for i in $(seq 0 $((width - 1))); do
                        pixmap+=("-1")
                done
                height=$((height += 1))
        done
}

init_binary_to_sixel_map() {
	for bin in {0..1}{0..1}{0..1}{0..1}{0..1}{0..1}; do
		binary_to_sixel_map["$bin"]="$(printf "\x$(printf '%x' $((2#$bin + 2#111111)))")"
	done
}

pixmap_to_sixel() {
	local begin_idx=0 # Index of the top-left pixel of a six pixel high
	                  # row.

	heatmap+='Pq'

	# Define color pallete
	for color_idx in "${!colors[@]}"; do
		heatmap+="#$color_idx;2;${colors[$color_idx]}"
	done

	while ((begin_idx < ${#pixmap[@]})); do
		for color_idx in "${!colors[@]}"; do
			heatmap+="#$color_idx"
			for col_idx in $(seq $begin_idx $((begin_idx + (width - 1)))); do
				local binary=""
				for idx in $(seq "$col_idx" $width $((col_idx + 5*width))); do
					if ((pixmap[idx] == color_idx)); then
						binary="1$binary"
					else
						binary="0$binary"
					fi
				done
				heatmap+="${binary_to_sixel_map[$binary]}"
			done
			if ((color_idx != ${#colors[@]} - 1)); then
				heatmap+='$'
			else
				heatmap+='$-'
			fi
		done
		begin_idx=$((begin_idx + 6*width))
	done

	heatmap+='\'
}

main() {
        input=($(cat -))
        find_min_max
        map_input_to_cells
        generate_pixmap
	init_binary_to_sixel_map
	pixmap_to_sixel
	echo -e "$heatmap"
}

main
